<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Joy Division Depth Clipping</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 12px 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 10;
            flex-shrink: 0;
        }

        .btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 1.5px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(8px);
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            font-size: 24px;
            font-weight: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

            .btn:hover {
                background: rgba(255,255,255,0.15);
                transform: scale(1.08);
            }

            .btn:active {
                transform: scale(0.94);
                background: rgba(255,255,255,0.2);
            }

        .active {
            background: rgba(255,255,255,0.25) !important;
            border-color: rgba(255,255,255,0.6);
        }

        canvas {
            display: block;
            background: #000;
            flex-grow: 1;
        }

        /* Mobile: canvas takes exactly 50% of remaining height after controls */
        @media (max-width: 768px) {
            .canvas-container {
                flex-grow: 0;
                height: calc(50vh - 40px); /* approximate half screen minus controls */
                max-height: 50vh;
            }
        }
    </style>
</head>
<body>

    <div class="controls">
        <button id="toggleBtn" class="btn">~</button>
        <button id="plusBtn" class="btn active">+</button>
        <button id="resetBtn" class="btn">×</button>
        <button id="explodeBtn" class="btn">!</button>
    </div>

    <div class="canvas-container">
        <canvas id="joyCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("joyCanvas");
        const ctx = canvas.getContext("2d");

        const toggleBtn = document.getElementById("toggleBtn");
        const plusBtn = document.getElementById("plusBtn");
        const resetBtn = document.getElementById("resetBtn");
        const explodeBtn = document.getElementById("explodeBtn");

        let width, height;

        const lineCount = 80;
        const pointsPerLine = 300;

        const marginTop = 20;
        const marginBottom = 20;
        const marginLeft = 20;
        const marginRight = 20;

        let mouseX = 0;
        let mouseY = 0;

        let mouseEnabled = true;

        let isMouseDown = false;
        let lastX = null;
        let lastY = null;
        const minDistance = 12;

        const distortionField = [];

        const radius = 30;
        const strength = 0.075;
        const radiusSq = radius * radius;
        const MAX_DISTORTION = 0.5;

        let explosionStart = null;

        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

        function initDistortionField() {
            for (let y = 0; y < height; y++) {
                distortionField[y] = new Float32Array(width);
            }
        }

        function applyGaussian(x0, y0) {
            const minX = Math.max(0, Math.floor(x0 - radius));
            const maxX = Math.min(width - 1, Math.floor(x0 + radius));
            const minY = Math.max(0, Math.floor(y0 - radius));
            const maxY = Math.min(height - 1, Math.floor(y0 + radius));

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const dx = x - x0;
                    const dy = y - y0;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= radiusSq) {
                        const g = Math.exp(-distSq / (radiusSq * 0.5));
                        distortionField[y][x] += strength * g;
                        distortionField[y][x] = clamp(distortionField[y][x], -MAX_DISTORTION, MAX_DISTORTION);
                    }
                }
            }
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const controlsHeight = document.querySelector('.controls').offsetHeight;

            width = window.innerWidth;
            let availableHeight = window.innerHeight - controlsHeight;

            // On mobile: limit canvas to half screen height
            if (window.innerWidth <= 768) {
                availableHeight = Math.min(availableHeight, window.innerHeight / 2);
            }

            height = availableHeight;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr);

            distortionField.length = 0;
            initDistortionField();

            mouseX = width / 2;
            mouseY = height / 2;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Rest of your event listeners and functions remain unchanged
        toggleBtn.addEventListener("click", () => {
            mouseEnabled = !mouseEnabled;
            toggleBtn.style.opacity = mouseEnabled ? "1" : "0.4";
        });

        resetBtn.addEventListener("click", () => {
            for (let y = 0; y < height; y++) distortionField[y].fill(0);
        });

        explodeBtn.addEventListener("click", () => {
            explosionStart = performance.now();
        });

        // Touch/Mouse handlers (unchanged from previous stable version)
        function handleStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            isMouseDown = true;
            lastX = x;
            lastY = y;

            applyGaussian(x, y);
        }

        function handleMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;

            if (!isMouseDown) return;

            const x = mouseX;
            const y = mouseY;

            if (lastX === null) { lastX = x; lastY = y; return; }

            const dist = Math.hypot(x - lastX, y - lastY);
            if (dist >= minDistance) {
                applyGaussian(x, y);
                lastX = x;
                lastY = y;
            }
        }

        function handleEnd() {
            isMouseDown = false;
            lastX = null;
            lastY = null;
        }

        canvas.addEventListener("mousedown", handleStart);
        canvas.addEventListener("mousemove", handleMove);
        canvas.addEventListener("mouseup", handleEnd);
        canvas.addEventListener("mouseleave", handleEnd);
        canvas.addEventListener("touchstart", handleStart, { passive: false });
        canvas.addEventListener("touchmove", handleMove, { passive: false });
        canvas.addEventListener("touchend", handleEnd);

        function smoothNoise(seed) {
            const x = Math.sin(seed * 12.9898) * 43758.5453;
            return x - Math.floor(x);
        }

        function interpolatedNoise(x) {
            const x0 = Math.floor(x);
            const x1 = x0 + 1;
            const t = x - x0;
            const n0 = smoothNoise(x0);
            const n1 = smoothNoise(x1);
            return n0 * (1 - t) + n1 * t;
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, width, height);

            const usableWidth = width - marginLeft - marginRight;
            const usableHeight = height - marginTop - marginBottom;
            const maxDisplacement = Math.min(100, height * 0.15);

            // Precompute all line Y positions for depth clipping
            const lineYs = new Array(lineCount);
            for (let i = 0; i < lineCount; i++) {
                lineYs[i] = new Float32Array(pointsPerLine);
            }

            let flattenFactor = 1;
            if (explosionStart !== null) {
                const elapsed = (performance.now() - explosionStart) / 1000;
                const flattenDuration = 5;
                const totalDuration = 19;

                if (elapsed < flattenDuration) {
                    flattenFactor = 1 - (elapsed / flattenDuration) * 0.95;
                } else if (elapsed < totalDuration) {
                    flattenFactor = 0.05 + Math.min(1, (elapsed - flattenDuration) / 14) * 0.95;
                } else {
                    explosionStart = null;
                    flattenFactor = 1;
                }
            }

            // First pass: compute all Y positions
            for (let i = 0; i < lineCount; i++) {
                const t = i / (lineCount - 1);
                const yBase = marginTop + t * usableHeight;
                const verticalDistortion = Math.sin(t * Math.PI) * 0.2;

                for (let j = 0; j < pointsPerLine; j++) {
                    const xNorm = j / (pointsPerLine - 1);
                    const x = marginLeft + xNorm * usableWidth;
                    const sideFalloff = Math.sin(xNorm * Math.PI);

                    let wave =
                        Math.sin(xNorm * 8 * Math.PI * 2) * 0.6 +
                        Math.sin(xNorm * 18 * Math.PI * 2) * 0.3;

                    const noise = (interpolatedNoise(j * 0.3 + i * 5.1) - 0.5) * 1.2;

                    let mouseInfluence = 0;
                    if (mouseEnabled) {
                        const dist = Math.hypot(x - mouseX, yBase - mouseY);
                        mouseInfluence = Math.max(0, 1 - dist / 30) * 0.6;
                    }

                    const permanent = distortionField[Math.floor(yBase)] ? distortionField[Math.floor(yBase)][Math.floor(x)] : 0;

                    let radialExplosion = 0;
                    if (explosionStart !== null) {
                        const elapsed = (performance.now() - explosionStart) / 1000;
                        if (elapsed >= 5 && elapsed < 19) {
                            const explosionElapsed = elapsed - 5;
                            const tExp = explosionElapsed / 14;
                            const centerX = width / 2;
                            const centerY = height / 2;
                            const dist = Math.hypot(x - centerX, yBase - centerY);
                            const maxRadius = Math.hypot(width, height) / 2;
                            const waveRadius = tExp * maxRadius;

                            let envelope = tExp < 0.4286 ? tExp / 0.4286 :
                                tExp < 0.5714 ? 1 :
                                    (1 - tExp) / 0.4286;

                            const phase = dist - waveRadius;
                            radialExplosion = Math.sin(phase * 0.075) * 0.6 * envelope / (1 + dist * dist * 0.00005);
                        }
                    }

                    const distortion = clamp(
                        verticalDistortion * sideFalloff +
                        mouseInfluence +
                        permanent +
                        radialExplosion,
                        -1.5,
                        1.5
                    );

                    wave = (wave + noise * 0.8) * flattenFactor + noise * 0.2 * flattenFactor;
                    wave = wave * distortion;

                    const yOffset = -wave * maxDisplacement;
                    lineYs[i][j] = yBase + yOffset;
                }
            }

            // Second pass: draw from back to front with clipping
            for (let i = lineCount - 1; i >= 0; i--) { // draw back lines first
                const t = i / (lineCount - 1);
                const yBase = marginTop + t * usableHeight;

                ctx.beginPath();

                let started = false;

                for (let j = 0; j < pointsPerLine; j++) {
                    const xNorm = j / (pointsPerLine - 1);
                    const x = marginLeft + xNorm * usableWidth;
                    const y = lineYs[i][j];

                    // Check if this point is hidden by any lower (front) line
                    let hidden = false;
                    for (let k = i + 1; k < lineCount; k++) { // check lines below (in front)
                        if (lineYs[k][j] < y) {
                            hidden = true;
                            break;
                        }
                    }

                    if (!hidden) {
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    } else if (started) {
                        // End current segment if hidden
                        ctx.stroke();
                        ctx.beginPath();
                        started = false;
                    }
                }

                if (started) ctx.stroke();

                // Glow on visible peaks
                let maxPeak = 0;
                for (let j = 0; j < pointsPerLine; j++) {
                    const waveY = yBase - lineYs[i][j]; // positive when peak is up
                    maxPeak = Math.max(maxPeak, waveY / maxDisplacement);
                }

                const glowStrength = clamp(maxPeak * 3, 0, 1);
                if (glowStrength > 0.05) {
                    ctx.shadowBlur = 20 + glowStrength * 60;
                    ctx.shadowColor = `rgba(255, 255, 255, ${0.8 + glowStrength * 0.2})`;
                } else {
                    ctx.shadowBlur = 0;
                }

                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = 1.6;
            }

            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>