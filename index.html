<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Joy Division Depth Clipping</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: sans-serif;
            touch-action: manipulation;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 40px;
            padding: 12px 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 10;
            flex-shrink: 0;
        }

        .btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 1.5px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            backdrop-filter: blur(8px);
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            font-size: 24px;
            font-weight: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

            .btn:hover {
                background: rgba(255,255,255,0.15);
                transform: scale(1.08);
            }

            .btn:active {
                transform: scale(0.94);
                background: rgba(255,255,255,0.2);
            }

        .active {
            background: rgba(255,255,255,0.25) !important;
            border-color: rgba(255,255,255,0.6);
        }

        canvas {
            display: block;
            background: #000;
        }

        /* Mobile devices (width ≤ 767px): 2/3 of screen height */
        @media (max-width: 767px) {
            canvas {
                height: calc(100vh / 3 * 2); /* exactly 2/3 of viewport height */
            }
        }

        /* Tablets & Desktops: almost full screen (minus controls) */
        @media (min-width: 768px) {
            canvas {
                height: calc(100vh - 72px); /* ~72px for controls */
            }
        }
    </style>
</head>
<body>

    <div class="controls">
        <button id="distortBtn" class="btn">~</button>
        <button id="resetBtn" class="btn">×</button>
        <button id="explodeBtn" class="btn">!</button>
    </div>

    <canvas id="joyCanvas"></canvas>

    <script>
        const canvas = document.getElementById("joyCanvas");
        const ctx = canvas.getContext("2d");

        const distortBtn = document.getElementById("distortBtn");
        const resetBtn = document.getElementById("resetBtn");
        const explodeBtn = document.getElementById("explodeBtn");

        let width, height;

        const lineCount = 80;
        const pointsPerLine = 300;

        const marginTop = 20;
        const marginBottom = 20;
        const marginLeft = 20;
        const marginRight = 20;

        let mouseX = 0;
        let mouseY = 0;

        // Distort mode now defaults to OFF
        let distortModeEnabled = false;

        let isMouseDown = false;
        let lastX = null;
        let lastY = null;
        const minDistance = 12;

        const distortionField = [];

        const radius = 30;
        const strength = 0.075;
        const radiusSq = radius * radius;
        const MAX_DISTORTION = 0.5;

        let explosionStart = null;

        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

        function initDistortionField() {
            for (let y = 0; y < height; y++) {
                distortionField[y] = new Float32Array(width);
            }
        }

        function applyGaussian(x0, y0) {
            const minX = Math.max(0, Math.floor(x0 - radius));
            const maxX = Math.min(width - 1, Math.floor(x0 + radius));
            const minY = Math.max(0, Math.floor(y0 - radius));
            const maxY = Math.min(height - 1, Math.floor(y0 + radius));

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const dx = x - x0;
                    const dy = y - y0;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= radiusSq) {
                        const g = Math.exp(-distSq / (radiusSq * 0.5));
                        distortionField[y][x] += strength * g;
                        distortionField[y][x] = clamp(distortionField[y][x], -MAX_DISTORTION, MAX_DISTORTION);
                    }
                }
            }
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;

            width = window.innerWidth;
            height = canvas.offsetHeight;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr);

            distortionField.length = 0;
            initDistortionField();

            mouseX = width / 2;
            mouseY = height / 2;
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        resizeCanvas();

        // Toggle starts OFF – button not highlighted
        distortBtn.addEventListener("click", () => {
            distortModeEnabled = !distortModeEnabled;
            distortBtn.classList.toggle("active", distortModeEnabled);
        });

        resetBtn.addEventListener("click", () => {
            for (let y = 0; y < height; y++) distortionField[y].fill(0);
        });

        explodeBtn.addEventListener("click", () => {
            explosionStart = performance.now();
        });

        function handleStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            isMouseDown = true;
            lastX = x;
            lastY = y;

            if (distortModeEnabled) {
                applyGaussian(x, y);
            }
        }

        function handleMove(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;

            if (!distortModeEnabled || !isMouseDown) return;

            const x = mouseX;
            const y = mouseY;

            if (lastX === null) { lastX = x; lastY = y; return; }

            const dist = Math.hypot(x - lastX, y - lastY);
            if (dist >= minDistance) {
                applyGaussian(x, y);
                lastX = x;
                lastY = y;
            }
        }

        function handleEnd() {
            isMouseDown = false;
            lastX = null;
            lastY = null;
        }

        canvas.addEventListener("mousedown", handleStart);
        canvas.addEventListener("mousemove", handleMove);
        canvas.addEventListener("mouseup", handleEnd);
        canvas.addEventListener("mouseleave", handleEnd);
        canvas.addEventListener("touchstart", handleStart, { passive: false });
        canvas.addEventListener("touchmove", handleMove, { passive: false });
        canvas.addEventListener("touchend", handleEnd);

        function hash11(p) {
            let n = p * 127.1 + p * 269.5;
            n = Math.sin(n) * 43758.5453;
            return n - Math.floor(n);
        }

        function perlinNoise(x) {
            const i = Math.floor(x);
            const f = x - i;
            const a = hash11(i);
            const b = hash11(i + 1);
            const u = f * f * (3 - 2 * f);
            return a * (1 - u) + b * u;
        }

        function fbm(x, y) {
            let total = 0;
            let amp = 0.5;
            let freq = 0.04;

            total += perlinNoise(x * freq + y * 0.37 + 12.34) * amp;
            freq *= 2.13; amp *= 0.5;

            total += perlinNoise(x * freq * 1.1 - y * 0.61 + 56.78) * amp;
            freq *= 2.37; amp *= 0.5;

            total += perlinNoise(x * freq + y * 1.23 + 90.12) * amp;
            freq *= 2.81; amp *= 0.5;

            total += perlinNoise(x * freq * 0.9 + y * 0.83 + 345.67) * amp;

            return total;
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, width, height);

            const usableWidth = width - marginLeft - marginRight;
            const usableHeight = height - marginTop - marginBottom;
            const maxDisplacement = Math.min(320, height * 0.48);

            const lineYs = new Array(lineCount);
            for (let i = 0; i < lineCount; i++) {
                lineYs[i] = new Float32Array(pointsPerLine);
            }

            let flattenFactor = 1;
            if (explosionStart !== null) {
                const elapsed = (performance.now() - explosionStart) / 1000;
                const flattenDuration = 5;
                const totalDuration = 19;

                if (elapsed < flattenDuration) {
                    flattenFactor = 1 - (elapsed / flattenDuration) * 0.95;
                } else if (elapsed < totalDuration) {
                    flattenFactor = 0.05 + Math.min(1, (elapsed - flattenDuration) / 14) * 0.95;
                } else {
                    explosionStart = null;
                    flattenFactor = 1;
                }
            }

            for (let i = 0; i < lineCount; i++) {
                const t = i / (lineCount - 1);
                const yBase = marginTop + t * usableHeight;
                const verticalDistortion = Math.sin(t * Math.PI) * 0.2;

                for (let j = 0; j < pointsPerLine; j++) {
                    const xNorm = j / (pointsPerLine - 1);
                    const x = marginLeft + xNorm * usableWidth;
                    const sideFalloff = Math.sin(xNorm * Math.PI);

                    let wave = Math.sin(xNorm * 10 * Math.PI) * 0.1;

                    const noiseInputX = j * 0.8;
                    const noiseInputY = i * 7.3;
                    const rawNoise = fbm(noiseInputX, noiseInputY);
                    const noiseVal = (rawNoise - 0.5) * 2.4;

                    let mouseInfluence = 0;
                    if (distortModeEnabled) {
                        const dist = Math.hypot(x - mouseX, yBase - mouseY);
                        mouseInfluence = Math.max(0, 1 - dist / 30) * 0.6;
                    }

                    const permanent = distortionField[Math.floor(yBase)] ? distortionField[Math.floor(yBase)][Math.floor(x)] : 0;

                    let radialExplosion = 0;
                    if (explosionStart !== null) {
                        const elapsed = (performance.now() - explosionStart) / 1000;
                        if (elapsed >= 5 && elapsed < 19) {
                            const explosionElapsed = elapsed - 5;
                            const tExp = explosionElapsed / 14;
                            const centerX = width / 2;
                            const centerY = height / 2;
                            const dist = Math.hypot(x - centerX, yBase - centerY);
                            const maxRadius = Math.hypot(width, height) / 2;
                            const waveRadius = tExp * maxRadius;

                            let envelope = tExp < 0.4286 ? tExp / 0.4286 :
                                tExp < 0.5714 ? 1 :
                                    (1 - tExp) / 0.4286;

                            const phase = dist - waveRadius;
                            radialExplosion = Math.sin(phase * 0.075) * 0.6 * envelope / (1 + dist * dist * 0.00005);
                        }
                    }

                    const distortion = clamp(
                        verticalDistortion * sideFalloff +
                        mouseInfluence +
                        permanent +
                        radialExplosion,
                        -1.5,
                        1.5
                    );

                    wave = (wave + noiseVal) * flattenFactor;
                    wave = wave * distortion;

                    const yOffset = -wave * maxDisplacement;
                    lineYs[i][j] = yBase + yOffset;
                }
            }

            for (let i = lineCount - 1; i >= 0; i--) {
                const t = i / (lineCount - 1);
                const yBase = marginTop + t * usableHeight;

                ctx.beginPath();
                let started = false;

                for (let j = 0; j < pointsPerLine; j++) {
                    const xNorm = j / (pointsPerLine - 1);
                    const x = marginLeft + xNorm * usableWidth;
                    const y = lineYs[i][j];

                    let hidden = false;
                    for (let k = i + 1; k < lineCount; k++) {
                        if (lineYs[k][j] < y) {
                            hidden = true;
                            break;
                        }
                    }

                    if (!hidden) {
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    } else if (started) {
                        ctx.stroke();
                        ctx.beginPath();
                        started = false;
                    }
                }

                if (started) ctx.stroke();

                let maxPeak = 0;
                for (let j = 0; j < pointsPerLine; j++) {
                    const waveY = yBase - lineYs[i][j];
                    maxPeak = Math.max(maxPeak, waveY / maxDisplacement);
                }

                const glowStrength = clamp(maxPeak * 3, 0, 1);
                if (glowStrength > 0.05) {
                    ctx.shadowBlur = 20 + glowStrength * 60;
                    ctx.shadowColor = `rgba(255, 255, 255, ${0.8 + glowStrength * 0.2})`;
                } else {
                    ctx.shadowBlur = 0;
                }

                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = 1.6;
            }

            requestAnimationFrame(draw);
        }

        draw();
    </script>
</body>
</html>